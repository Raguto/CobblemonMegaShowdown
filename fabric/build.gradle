plugins {
    id 'com.github.johnrengelman.shadow'
}

architectury {
    platformSetupLoomIde()
    fabric()
}

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentFabric.extendsFrom common

    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }
}

dependencies {
    modImplementation "net.fabricmc:fabric-loader:$project.fabric_loader_version"

    modImplementation "net.fabricmc.fabric-api:fabric-api:$project.fabric_api_version"

    modImplementation "dev.architectury:architectury-fabric:$project.architectury_api_version"

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowBundle project(path: ':common', configuration: 'transformProductionFabric')

    modImplementation "net.fabricmc:fabric-language-kotlin:$project.kotlin_fabric_version"

    modImplementation "io.wispforest:accessories-fabric:${project.accessories_version}"
    modImplementation "com.cobblemon:fabric:${project.cobblemon_version}"
}

processResources {
    inputs.property 'version', project.version

    filesMatching('fabric.mod.json') {
        expand version: project.version
    }
}

shadowJar {
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'
}

remapJar {
    input.set shadowJar.archiveFile
}

task deploy {
    dependsOn tasks.named('remapJar')
    
    doLast {
        def modsDir = file('D:/instances/1.21.1(2)/minecraft/mods')

        if (!modsDir.exists()) {
            logger.warn("deploy: target mods directory does not exist: ${modsDir}")
            return
        }

        modsDir.listFiles().each { f ->
            try {
                if (f.name.contains('mega_showdown') && f.name.endsWith('.jar')) {
                    logger.lifecycle("deploy: deleting old jar from mods folder: ${f.name}")
                    f.delete()
                }
            } catch (Throwable e) {
                logger.warn("deploy: failed to delete ${f.name}: ${e.message}")
            }
        }

        def remapJar = tasks.named('remapJar').get()
        copy {
            from remapJar.archiveFile
            into modsDir
        }

        logger.lifecycle("deploy: copied ${remapJar.archiveFile.get().asFile.name} to ${modsDir}")
    }
}

tasks.named('build') {
    finalizedBy deploy
}